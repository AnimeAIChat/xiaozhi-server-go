# xiaozhi-server-go 架构迁移详细执行计划

## 项目概述

**项目名称：** xiaozhi-server-go  
**当前状态：** 混合架构（传统单体架构 src + DDD架构 internal）  
**迁移目标：** 完全采用领域驱动设计（DDD）架构，移除向后兼容代码  
**预期收益：** 提高代码可维护性、可测试性和可扩展性  
**总时间：** 16周（4个月）  
**负责人：** 架构迁移小组  

## 架构现状分析

### 当前架构问题清单

1. **循环依赖问题**
   - bootstrap.go 导入 providers 等10+个包
   - base.go 依赖 llm
   - connection.go 混用新旧架构组件

2. **接口重复定义**
   - base.go 定义 Provider 接口
   - interfaces.go 重新定义相同接口
   - llm.go 又有另一套定义

3. **配置管理混乱**
   - configs 和 config 并存
   - 两套配置加载逻辑

4. **测试覆盖不足**
   - src 目录测试覆盖率 <50%
   - internal 目录缺少集成测试

## 迁移总体策略

### 原则
- **渐进式迁移**：分阶段完成，避免大爆炸式重构
- **测试先行**：每个步骤先写测试，再实现代码
- **保持兼容**：直到最后阶段才移除旧代码
- **可回滚**：设立检查点，支持快速回滚

### 总体时间表
- **阶段1：** 准备阶段（第1-2周）
- **阶段2：** 核心领域迁移（第3-8周）
- **阶段3：** 外围模块迁移（第9-14周）
- **阶段4：** 清理和优化（第15-16周）

### 成功标准
- ✅ 代码行数减少 25%
- ✅ 单元测试覆盖率 >85%
- ✅ 性能提升 10%
- ✅ 零向后兼容代码

## 阶段1：准备阶段（第1-2周）

### 目标
建立迁移基础设施，冻结旧架构，确保迁移过程可控。

### 详细执行步骤

#### 1.1 建立迁移分支和环境

**执行命令：**
```bash
# 创建迁移分支
git checkout -b architecture-migration-v1.0
git push -u origin architecture-migration-v1.0

# 安装必要工具
go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest
go install github.com/kyoh86/richgo@latest
go install github.com/cosmtrek/air@latest
go install github.com/stretchr/testify@latest
go install github.com/vektra/mockery/v2@latest

# 验证安装
golangci-lint --version
richgo version
air -v
```

**预期输出：**
```
golangci-lint has version 1.55.2 built with go1.21.3
richgo version 0.3.10
  __    _   ___  
 / /\  | | | |_) 
/_/--\ |_| |_| \_ 1.49.0
```

#### 1.2 完善新架构基础组件

**1.2.1 创建统一错误处理**

创建文件：errors.go

```go
package errors

import (
    "fmt"
    "errors"
)

type Kind string

const (
    KindConfig     Kind = "config"
    KindDomain     Kind = "domain" 
    KindTransport  Kind = "transport"
    KindPlatform   Kind = "platform"
    KindBootstrap  Kind = "bootstrap"
)

type Error struct {
    Kind    Kind
    Op      string  // 操作名称
    Message string
    Cause   error
}

func (e *Error) Error() string {
    if e.Cause != nil {
        return fmt.Sprintf("[%s:%s] %s: %v", e.Kind, e.Op, e.Message, e.Cause)
    }
    return fmt.Sprintf("[%s:%s] %s", e.Kind, e.Op, e.Message)
}

func (e *Error) Unwrap() error {
    return e.Cause
}

func Wrap(kind Kind, op, message string, err error) *Error {
    if err == nil {
        return nil
    }
    
    var typed *Error
    if errors.As(err, &typed) {
        return typed
    }
    
    return &Error{
        Kind:    kind,
        Op:      op,
        Message: message,
        Cause:   err,
    }
}

func New(kind Kind, op, message string) *Error {
    return &Error{
        Kind:    kind,
        Op:      op,
        Message: message,
    }
}
```

创建对应的测试文件：`internal/platform/errors/errors_test.go`

```go
package errors

import (
    "errors"
    "strings"
    "testing"
)

func TestError_Error(t *testing.T) {
    tests := []struct {
        name     string
        err      *Error
        contains []string
    }{
        {
            name: "error with cause",
            err: Wrap(KindConfig, "load", "failed to load config", 
                errors.New("file not found")),
            contains: []string{"[config:load]", "failed to load config", "file not found"},
        },
        {
            name: "error without cause",
            err: New(KindDomain, "validate", "invalid input"),
            contains: []string{"[domain:validate]", "invalid input"},
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            errStr := tt.err.Error()
            for _, substr := range tt.contains {
                if !strings.Contains(errStr, substr) {
                    t.Errorf("error string %q does not contain %q", errStr, substr)
                }
            }
        })
    }
}

func TestError_Unwrap(t *testing.T) {
    originalErr := errors.New("original error")
    wrappedErr := Wrap(KindConfig, "test", "wrapped", originalErr)
    
    if !errors.Is(wrappedErr, originalErr) {
        t.Error("Unwrap should return the original error")
    }
}
```

**1.2.2 完善配置管理**

创建文件：`internal/platform/config/config.go`

```go
package config

import (
    "time"
    
    "xiaozhi-server-go/internal/platform/errors"
)

type Config struct {
    Server   ServerConfig   `yaml:"server" mapstructure:"server"`
    Log      LogConfig      `yaml:"log" mapstructure:"log"`
    Web      WebConfig      `yaml:"web" mapstructure:"web"`
    LLM      LLMConfig      `yaml:"llm" mapstructure:"llm"`
    TTS      TTSConfig      `yaml:"tts" mapstructure:"tts"`
    ASR      ASRConfig      `yaml:"asr" mapstructure:"asr"`
    VLLLM    VLLLMConfig    `yaml:"vlllm" mapstructure:"vlllm"`
    MCP      MCPConfig      `yaml:"mcp" mapstructure:"mcp"`
    Selected SelectedConfig `yaml:"selected_module" mapstructure:"selected_module"`
}

type ServerConfig struct {
    IP     string `yaml:"ip" mapstructure:"ip"`
    Port   int    `yaml:"port" mapstructure:"port"`
    Token  string `yaml:"token" mapstructure:"token"`
    Auth   AuthConfig `yaml:"auth" mapstructure:"auth"`
}

type AuthConfig struct {
    Enabled bool   `yaml:"enabled" mapstructure:"enabled"`
    Store   StoreConfig `yaml:"store" mapstructure:"store"`
}

type StoreConfig struct {
    Type     string `yaml:"type" mapstructure:"type"`
    Expiry   string `yaml:"expiry" mapstructure:"expiry"`
    Cleanup  string `yaml:"cleanup" mapstructure:"cleanup"`
}

type LogConfig struct {
    Level    string `yaml:"log_level" mapstructure:"log_level"`
    Dir      string `yaml:"log_dir" mapstructure:"log_dir"`
    File     string `yaml:"log_file" mapstructure:"log_file"`
    Format   string `yaml:"log_format" mapstructure:"log_format"`
}

type WebConfig struct {
    Enabled     bool   `yaml:"enabled" mapstructure:"enabled"`
    Port        int    `yaml:"port" mapstructure:"port"`
    Websocket   string `yaml:"websocket" mapstructure:"websocket"`
    VisionURL   string `yaml:"vision" mapstructure:"vision"`
    ActivateText string `yaml:"activate_text" mapstructure:"activate_text"`
}

type LLMConfig struct {
    Type        string  `yaml:"type" mapstructure:"type"`
    Model       string  `yaml:"model_name" mapstructure:"model_name"`
    APIKey      string  `yaml:"api_key" mapstructure:"api_key"`
    BaseURL     string  `yaml:"url" mapstructure:"url"`
    Temperature float64 `yaml:"temperature" mapstructure:"temperature"`
    MaxTokens   int     `yaml:"max_tokens" mapstructure:"max_tokens"`
    TopP        float64 `yaml:"top_p" mapstructure:"top_p"`
}

type TTSConfig struct {
    Type            string            `yaml:"type" mapstructure:"type"`
    Voice           string            `yaml:"voice" mapstructure:"voice"`
    OutputDir       string            `yaml:"output_dir" mapstructure:"output_dir"`
    Format          string            `yaml:"format" mapstructure:"format"`
    SupportedVoices []VoiceInfo       `yaml:"supported_voices" mapstructure:"supported_voices"`
}

type VoiceInfo struct {
    Name        string `yaml:"name" mapstructure:"name"`
    DisplayName string `yaml:"display_name" mapstructure:"display_name"`
    Sex         string `yaml:"sex" mapstructure:"sex"`
    Description string `yaml:"description" mapstructure:"description"`
    AudioURL    string `yaml:"audio_url" mapstructure:"audio_url"`
}

type ASRConfig struct {
    Type        string `yaml:"type" mapstructure:"type"`
    AppID       string `yaml:"appid" mapstructure:"appid"`
    AccessToken string `yaml:"access_token" mapstructure:"access_token"`
    OutputDir   string `yaml:"output_dir" mapstructure:"output_dir"`
}

type VLLLMConfig struct {
    Type        string  `yaml:"type" mapstructure:"type"`
    Model       string  `yaml:"model_name" mapstructure:"model_name"`
    APIKey      string  `yaml:"api_key" mapstructure:"api_key"`
    BaseURL     string  `yaml:"url" mapstructure:"url"`
    MaxTokens   int     `yaml:"max_tokens" mapstructure:"max_tokens"`
    Temperature float64 `yaml:"temperature" mapstructure:"temperature"`
    TopP        float64 `yaml:"top_p" mapstructure:"top_p"`
}

type MCPConfig struct {
    Enabled bool `yaml:"enabled" mapstructure:"enabled"`
}

type SelectedConfig struct {
    ASR   string `yaml:"ASR" mapstructure:"ASR"`
    TTS   string `yaml:"TTS" mapstructure:"TTS"`
    LLM   string `yaml:"LLM" mapstructure:"LLM"`
    VLLLM string `yaml:"VLLLM" mapstructure:"VLLLM"`
}
```

创建文件：loader.go

```go
package config

import (
    "os"
    "path/filepath"
    
    "github.com/spf13/viper"
    "xiaozhi-server-go/internal/platform/errors"
)

type Loader struct {
    viper *viper.Viper
}

func NewLoader() *Loader {
    v := viper.New()
    v.SetConfigName(".config")
    v.SetConfigType("yaml")
    
    // 搜索路径
    searchPaths := []string{
        ".",
        "./config",
        filepath.Dir(os.Args[0]), // 可执行文件目录
    }
    
    for _, path := range searchPaths {
        v.AddConfigPath(path)
    }
    
    return &Loader{viper: v}
}

func (l *Loader) Load() (*Config, error) {
    // 设置默认值
    l.setDefaults()
    
    // 读取配置文件
    if err := l.viper.ReadInConfig(); err != nil {
        return nil, errors.Wrap(errors.KindConfig, "load", "failed to read config file", err)
    }
    
    var cfg Config
    if err := l.viper.Unmarshal(&cfg); err != nil {
        return nil, errors.Wrap(errors.KindConfig, "load", "failed to unmarshal config", err)
    }
    
    // 验证配置
    if err := l.validate(&cfg); err != nil {
        return nil, errors.Wrap(errors.KindConfig, "load", "config validation failed", err)
    }
    
    return &cfg, nil
}

func (l *Loader) setDefaults() {
    l.viper.SetDefault("server.ip", "0.0.0.0")
    l.viper.SetDefault("server.port", 8000)
    l.viper.SetDefault("web.port", 8080)
    l.viper.SetDefault("log.log_level", "INFO")
    l.viper.SetDefault("log.log_dir", "logs")
    l.viper.SetDefault("log.log_file", "server.log")
}

func (l *Loader) validate(cfg *Config) error {
    if cfg.Server.Port <= 0 || cfg.Server.Port > 65535 {
        return errors.New(errors.KindConfig, "validate", "invalid server port")
    }
    
    if cfg.Web.Port <= 0 || cfg.Web.Port > 65535 {
        return errors.New(errors.KindConfig, "validate", "invalid web port")
    }
    
    return nil
}
```

#### 1.3 建立测试框架

创建文件：`internal/platform/testing/helpers.go`

```go
package testing

import (
    "testing"
    "xiaozhi-server-go/internal/platform/config"
    "xiaozhi-server-go/internal/platform/logging"
)

func SetupTestConfig(t *testing.T) *config.Config {
    t.Helper()
    
    cfg := &config.Config{
        Server: config.ServerConfig{
            IP:   "127.0.0.1",
            Port: 8080,
        },
        Log: config.LogConfig{
            Level:  "DEBUG",
            Dir:    "/tmp/test_logs",
            File:   "test.log",
            Format: "{time} - {level} - {message}",
        },
        Web: config.WebConfig{
            Enabled:   true,
            Port:      8081,
            Websocket: "ws://127.0.0.1:8080",
        },
    }
    
    return cfg
}

func SetupTestLogger(t *testing.T) *logging.Logger {
    t.Helper()
    
    cfg := SetupTestConfig(t)
    logger, err := logging.New(logging.Config{
        Level:    cfg.Log.Level,
        Dir:      cfg.Log.Dir,
        Filename: cfg.Log.File,
    })
    
    if err != nil {
        t.Fatalf("failed to create test logger: %v", err)
    }
    
    return logger
}

func AssertNoError(t *testing.T, err error) {
    t.Helper()
    if err != nil {
        t.Fatalf("unexpected error: %v", err)
    }
}

func AssertError(t *testing.T, err error) {
    t.Helper()
    if err == nil {
        t.Fatal("expected error but got nil")
    }
}

func AssertEqual(t *testing.T, expected, actual interface{}) {
    t.Helper()
    if expected != actual {
        t.Fatalf("expected %v, got %v", expected, actual)
    }
}
```

#### 1.4 冻结旧架构

更新 `.golangci.yml` 文件：

```yaml
run:
  timeout: 5m
  issues-exit-code: 1
  tests: true

linters:
  enable:
    - gofmt
    - goimports
    - golint
    - govet
    - ineffassign
    - misspell
    - staticcheck
    - unused
    - errcheck
    - gosimple
    - gocyclo
    - funlen
    - nestif

linters-settings:
  gocyclo:
    min-complexity: 15
  funlen:
    lines: 100
    statements: 50

issues:
  exclude-rules:
    # 排除 src/ 目录的检查，因为我们要迁移它
    - path: src/
      linters:
        - gocyclo
        - funlen
        - nestif
```

创建自定义 linter：`tools/linters/src_frozen.go`

```go
package main

import (
    "fmt"
    "go/ast"
    "go/token"
    "strings"
    
    "golang.org/x/tools/go/analysis"
)

var Analyzer = &analysis.Analyzer{
    Name: "srcfrozen",
    Doc:  "prevents modifications to src/ directory during migration",
    Run:  run,
}

func run(pass *analysis.Pass) (interface{}, error) {
    for _, file := range pass.Files {
        if strings.Contains(pass.Fset.File(file.Pos()).Name(), "src/") {
            pass.Reportf(file.Pos(), "modifications to src/ directory are frozen during architecture migration")
        }
    }
    return nil, nil
}
```

### 验收标准
- [x] 新架构基础组件完整（错误处理、配置、日志、测试框架）
- [x] 单元测试框架建立，覆盖率 >80% for internal/
- [x] CI/CD 阻止对 src/ 的修改
- [x] 所有现有功能正常运行
- [x] 运行 `go test xiaozhi-server-go.` 通过

## 阶段2：核心领域迁移（第3-8周）

### 目标
迁移最核心的业务逻辑（LLM、TTS、ASR），消除主要依赖关系。

### 详细执行步骤

#### 2.1 LLM 领域重构

**2.1.1 定义领域模型**

创建文件：`internal/domain/llm/aggregate/message.go`

```go
package aggregate

import "time"

type Message struct {
    ID        string    `json:"id"`
    Role      string    `json:"role"`
    Content   string    `json:"content"`
    Name      string    `json:"name,omitempty"`
    ToolCalls []ToolCall `json:"tool_calls,omitempty"`
    ToolCallID string   `json:"tool_call_id,omitempty"`
    Timestamp time.Time `json:"timestamp"`
}

type ToolCall struct {
    ID       string         `json:"id"`
    Type     string         `json:"type"`
    Function ToolCallFunction `json:"function"`
    Index    int            `json:"index"`
}

type ToolCallFunction struct {
    Name      string `json:"name"`
    Arguments string `json:"arguments"`
}

type Tool struct {
    ID          string      `json:"id"`
    Type        string      `json:"type"`
    Function    ToolFunction `json:"function"`
    Description string      `json:"description,omitempty"`
}

type ToolFunction struct {
    Name        string      `json:"name"`
    Description string      `json:"description"`
    Parameters  interface{} `json:"parameters"`
}

type Config struct {
    Provider    string  `json:"provider"`
    Model       string  `json:"model"`
    APIKey      string  `json:"api_key"`
    BaseURL     string  `json:"base_url"`
    Temperature float32 `json:"temperature"`
    MaxTokens   int     `json:"max_tokens"`
    TopP        float32 `json:"top_p"`
    Timeout     int     `json:"timeout"`
}

type Usage struct {
    PromptTokens     int `json:"prompt_tokens"`
    CompletionTokens int `json:"completion_tokens"`
    TotalTokens      int `json:"total_tokens"`
}
```

**2.1.2 定义领域服务接口**

创建文件：`internal/domain/llm/service.go`

```go
package llm

import (
    "context"
    "xiaozhi-server-go/internal/domain/llm/aggregate"
)

type Service interface {
    GenerateResponse(ctx context.Context, req GenerateRequest) (*GenerateResponse, error)
    StreamResponse(ctx context.Context, req GenerateRequest) (<-chan ResponseChunk, error)
    ValidateConfig(config aggregate.Config) error
    GetSupportedProviders() []string
}

type GenerateRequest struct {
    SessionID string
    Messages  []aggregate.Message
    Tools     []aggregate.Tool
    Config    aggregate.Config
}

type GenerateResponse struct {
    Content   string
    ToolCalls []aggregate.ToolCall
    Usage     aggregate.Usage
    FinishReason string
}

type ResponseChunk struct {
    Content   string
    ToolCalls []aggregate.ToolCall
    Done      bool
    Usage     *aggregate.Usage
}
```

**2.1.3 实现领域服务**

创建文件：`internal/domain/llm/service_impl.go`

```go
package llm

import (
    "context"
    "fmt"
    "xiaozhi-server-go/internal/domain/llm/aggregate"
    "xiaozhi-server-go/internal/domain/llm/repository"
    "xiaozhi-server-go/internal/platform/errors"
)

type serviceImpl struct {
    repo repository.LLMRepository
}

func NewService(repo repository.LLMRepository) Service {
    return &serviceImpl{repo: repo}
}

func (s *serviceImpl) GenerateResponse(ctx context.Context, req GenerateRequest) (*GenerateResponse, error) {
    if err := s.ValidateConfig(req.Config); err != nil {
        return nil, errors.Wrap(errors.KindDomain, "generate", "config validation failed", err)
    }
    
    result, err := s.repo.Generate(ctx, repository.GenerateRequest{
        SessionID: req.SessionID,
        Messages:  convertMessages(req.Messages),
        Tools:     convertTools(req.Tools),
        Config:    req.Config,
    })
    
    if err != nil {
        return nil, errors.Wrap(errors.KindDomain, "generate", "repository call failed", err)
    }
    
    return &GenerateResponse{
        Content:   result.Content,
        ToolCalls: result.ToolCalls,
        Usage:     result.Usage,
        FinishReason: result.FinishReason,
    }, nil
}

func (s *serviceImpl) StreamResponse(ctx context.Context, req GenerateRequest) (<-chan ResponseChunk, error) {
    if err := s.ValidateConfig(req.Config); err != nil {
        return nil, errors.Wrap(errors.KindDomain, "stream", "config validation failed", err)
    }
    
    stream, err := s.repo.Stream(ctx, repository.GenerateRequest{
        SessionID: req.SessionID,
        Messages:  convertMessages(req.Messages),
        Tools:     convertTools(req.Tools),
        Config:    req.Config,
    })
    
    if err != nil {
        return nil, errors.Wrap(errors.KindDomain, "stream", "repository call failed", err)
    }
    
    outChan := make(chan ResponseChunk, 10)
    
    go func() {
        defer close(outChan)
        
        for chunk := range stream {
            outChan <- ResponseChunk{
                Content:   chunk.Content,
                ToolCalls: chunk.ToolCalls,
                Done:      chunk.Done,
                Usage:     chunk.Usage,
            }
        }
    }()
    
    return outChan, nil
}

func (s *serviceImpl) ValidateConfig(config aggregate.Config) error {
    if config.Provider == "" {
        return errors.New(errors.KindDomain, "validate", "provider cannot be empty")
    }
    
    if config.Model == "" {
        return errors.New(errors.KindDomain, "validate", "model cannot be empty")
    }
    
    if config.MaxTokens <= 0 {
        return errors.New(errors.KindDomain, "validate", "max_tokens must be positive")
    }
    
    if config.Temperature < 0 || config.Temperature > 2 {
        return errors.New(errors.KindDomain, "validate", "temperature must be between 0 and 2")
    }
    
    return nil
}

func (s *serviceImpl) GetSupportedProviders() []string {
    return []string{"openai", "doubao", "ollama", "coze"}
}

func convertMessages(domainMsgs []aggregate.Message) []repository.Message {
    msgs := make([]repository.Message, len(domainMsgs))
    for i, msg := range domainMsgs {
        msgs[i] = repository.Message{
            ID:        msg.ID,
            Role:      msg.Role,
            Content:   msg.Content,
            Name:      msg.Name,
            ToolCalls: convertToolCalls(msg.ToolCalls),
            ToolCallID: msg.ToolCallID,
            Timestamp: msg.Timestamp,
        }
    }
    return msgs
}

func convertToolCalls(domainCalls []aggregate.ToolCall) []repository.ToolCall {
    calls := make([]repository.ToolCall, len(domainCalls))
    for i, call := range domainCalls {
        calls[i] = repository.ToolCall{
            ID:       call.ID,
            Type:     call.Type,
            Function: repository.ToolCallFunction{
                Name:      call.Function.Name,
                Arguments: call.Function.Arguments,
            },
            Index: call.Index,
        }
    }
    return calls
}

func convertTools(domainTools []aggregate.Tool) []repository.Tool {
    tools := make([]repository.Tool, len(domainTools))
    for i, tool := range domainTools {
        tools[i] = repository.Tool{
            ID:   tool.ID,
            Type: tool.Type,
            Function: repository.ToolFunction{
                Name:        tool.Function.Name,
                Description: tool.Function.Description,
                Parameters:  tool.Function.Parameters,
            },
            Description: tool.Description,
        }
    }
    return tools
}
```

**2.1.4 定义仓库接口**

创建文件：`internal/domain/llm/repository/interface.go`

```go
package repository

import (
    "context"
    "time"
    "xiaozhi-server-go/internal/domain/llm/aggregate"
)

type LLMRepository interface {
    Generate(ctx context.Context, req GenerateRequest) (*GenerateResult, error)
    Stream(ctx context.Context, req GenerateRequest) (<-chan ResponseChunk, error)
    ValidateConnection(ctx context.Context, config aggregate.Config) error
    GetProviderInfo(provider string) (*ProviderInfo, error)
}

type GenerateRequest struct {
    SessionID string
    Messages  []Message
    Tools     []Tool
    Config    aggregate.Config
}

type GenerateResult struct {
    Content      string
    ToolCalls    []ToolCall
    Usage        *aggregate.Usage
    FinishReason string
}

type ResponseChunk struct {
    Content   string
    ToolCalls []ToolCall
    Done      bool
    Usage     *aggregate.Usage
}

type Message struct {
    ID        string
    Role      string
    Content   string
    Name      string
    ToolCalls []ToolCall
    ToolCallID string
    Timestamp time.Time
}

type ToolCall struct {
    ID       string
    Type     string
    Function ToolCallFunction
    Index    int
}

type ToolCallFunction struct {
    Name      string
    Arguments string
}

type Tool struct {
    ID          string
    Type        string
    Function    ToolFunction
    Description string
}

type ToolFunction struct {
    Name        string
    Description string
    Parameters  interface{}
}

type ProviderInfo struct {
    Name         string
    SupportedModels []string
    MaxTokens    int
    Features     []string
}
```

**2.1.5 实现基础设施层**

创建文件：`internal/domain/llm/infrastructure/openai_adapter.go`

```go
package infrastructure

import (
    "context"
    "encoding/json"
    "fmt"
    "strings"
    
    "github.com/sashabaranov/go-openai"
    "xiaozhi-server-go/internal/domain/llm/aggregate"
    "xiaozhi-server-go/internal/domain/llm/repository"
    "xiaozhi-server-go/internal/platform/errors"
)

type openaiAdapter struct {
    client *openai.Client
}

func NewOpenAIAdapter(apiKey, baseURL string) repository.LLMRepository {
    config := openai.DefaultConfig(apiKey)
    if baseURL != "" {
        config.BaseURL = baseURL
    }
    
    return &openaiAdapter{
        client: openai.NewClientWithConfig(config),
    }
}

func (o *openaiAdapter) Generate(ctx context.Context, req repository.GenerateRequest) (*repository.GenerateResult, error) {
    messages := o.convertMessages(req.Messages)
    tools := o.convertTools(req.Tools)
    
    chatReq := openai.ChatCompletionRequest{
        Model:    req.Config.Model,
        Messages: messages,
        Tools:    tools,
        Temperature: float32(req.Config.Temperature),
        MaxTokens:   req.Config.MaxTokens,
        TopP:        float32(req.Config.TopP),
    }
    
    resp, err := o.client.CreateChatCompletion(ctx, chatReq)
    if err != nil {
        return nil, errors.Wrap(errors.KindDomain, "openai.generate", "API call failed", err)
    }
    
    if len(resp.Choices) == 0 {
        return nil, errors.New(errors.KindDomain, "openai.generate", "no response choices")
    }
    
    choice := resp.Choices[0]
    result := &repository.GenerateResult{
        Content:      choice.Message.Content,
        FinishReason: string(choice.FinishReason),
        Usage: &aggregate.Usage{
            PromptTokens:     resp.Usage.PromptTokens,
            CompletionTokens: resp.Usage.CompletionTokens,
            TotalTokens:      resp.Usage.TotalTokens,
        },
    }
    
    // 处理工具调用
    if choice.Message.ToolCalls != nil {
        result.ToolCalls = make([]repository.ToolCall, len(choice.Message.ToolCalls))
        for i, tc := range choice.Message.ToolCalls {
            result.ToolCalls[i] = repository.ToolCall{
                ID:   tc.ID,
                Type: tc.Type,
                Function: repository.ToolCallFunction{
                    Name:      tc.Function.Name,
                    Arguments: tc.Function.Arguments,
                },
                Index: tc.Index,
            }
        }
    }
    
    return result, nil
}

func (o *openaiAdapter) Stream(ctx context.Context, req repository.GenerateRequest) (<-chan repository.ResponseChunk, error) {
    messages := o.convertMessages(req.Messages)
    tools := o.convertTools(req.Tools)
    
    chatReq := openai.ChatCompletionRequest{
        Model:    req.Config.Model,
        Messages: messages,
        Tools:    tools,
        Temperature: float32(req.Config.Temperature),
        MaxTokens:   req.Config.MaxTokens,
        TopP:        float32(req.Config.TopP),
        Stream:      true,
    }
    
    stream, err := o.client.CreateChatCompletionStream(ctx, chatReq)
    if err != nil {
        return nil, errors.Wrap(errors.KindDomain, "openai.stream", "stream creation failed", err)
    }
    
    outChan := make(chan repository.ResponseChunk, 10)
    
    go func() {
        defer close(outChan)
        defer stream.Close()
        
        for {
            response, err := stream.Recv()
            if err != nil {
                if strings.Contains(err.Error(), "stream closed") {
                    return
                }
                // 发送错误到通道
                outChan <- repository.ResponseChunk{
                    Content: fmt.Sprintf("Error: %v", err),
                    Done:    true,
                }
                return
            }
            
            if len(response.Choices) == 0 {
                continue
            }
            
            choice := response.Choices[0]
            chunk := repository.ResponseChunk{
                Content: choice.Delta.Content,
                Done:    choice.FinishReason != "",
            }
            
            // 处理工具调用
            if choice.Delta.ToolCalls != nil {
                chunk.ToolCalls = make([]repository.ToolCall, len(choice.Delta.ToolCalls))
                for i, tc := range choice.Delta.ToolCalls {
                    chunk.ToolCalls[i] = repository.ToolCall{
                        ID:   tc.ID,
                        Type: tc.Type,
                        Function: repository.ToolCallFunction{
                            Name:      tc.Function.Name,
                            Arguments: tc.Function.Arguments,
                        },
                        Index: tc.Index,
                    }
                }
            }
            
            // 处理使用情况
            if response.Usage != nil {
                chunk.Usage = &aggregate.Usage{
                    PromptTokens:     response.Usage.PromptTokens,
                    CompletionTokens: response.Usage.CompletionTokens,
                    TotalTokens:      response.Usage.TotalTokens,
                }
            }
            
            outChan <- chunk
            
            if chunk.Done {
                break
            }
        }
    }()
    
    return outChan, nil
}

func (o *openaiAdapter) ValidateConnection(ctx context.Context, config aggregate.Config) error {
    // 发送一个简单的请求来验证连接
    messages := []openai.ChatCompletionMessage{
        {Role: openai.ChatMessageRoleUser, Content: "Hello"},
    }
    
    req := openai.ChatCompletionRequest{
        Model:    config.Model,
        Messages: messages,
        MaxTokens: 10,
    }
    
    _, err := o.client.CreateChatCompletion(ctx, req)
    if err != nil {
        return errors.Wrap(errors.KindDomain, "openai.validate", "connection test failed", err)
    }
    
    return nil
}

func (o *openaiAdapter) GetProviderInfo(provider string) (*repository.ProviderInfo, error) {
    return &repository.ProviderInfo{
        Name: "OpenAI",
        SupportedModels: []string{
            "gpt-4",
            "gpt-4-turbo",
            "gpt-3.5-turbo",
        },
        MaxTokens: 128000,
        Features: []string{
            "chat",
            "tools",
            "streaming",
            "vision",
        },
    }, nil
}

func (o *openaiAdapter) convertMessages(msgs []repository.Message) []openai.ChatCompletionMessage {
    messages := make([]openai.ChatCompletionMessage, len(msgs))
    for i, msg := range msgs {
        messages[i] = openai.ChatCompletionMessage{
            Role:       msg.Role,
            Content:    msg.Content,
            Name:       msg.Name,
            ToolCalls:  o.convertToolCalls(msg.ToolCalls),
            ToolCallID: msg.ToolCallID,
        }
    }
    return messages
}

func (o *openaiAdapter) convertToolCalls(calls []repository.ToolCall) []openai.ToolCall {
    if len(calls) == 0 {
        return nil
    }
    
    toolCalls := make([]openai.ToolCall, len(calls))
    for i, call := range calls {
        toolCalls[i] = openai.ToolCall{
            ID:   call.ID,
            Type: call.Type,
            Function: openai.FunctionCall{
                Name:      call.Function.Name,
                Arguments: call.Function.Arguments,
            },
        }
    }
    return toolCalls
}

func (o *openaiAdapter) convertTools(tools []repository.Tool) []openai.Tool {
    if len(tools) == 0 {
        return nil
    }
    
    openaiTools := make([]openai.Tool, len(tools))
    for i, tool := range tools {
        params, _ := json.Marshal(tool.Function.Parameters)
        
        openaiTools[i] = openai.Tool{
            Type: openai.ToolType(tool.Type),
            Function: &openai.FunctionDefinition{
                Name:        tool.Function.Name,
                Description: tool.Function.Description,
                Parameters:  params,
            },
        }
    }
    return openaiTools
}
```

**2.1.6 更新Bootstrap**

修改文件：bootstrap.go

在 `initLLMService` 函数中添加：

```go
func initLLMService(cfg *config.Config, logger *utils.Logger) (domainllm.Service, error) {
    // 根据配置选择仓库实现
    var repo domainllm.Repository
    switch cfg.LLM.Type {
    case "openai":
        repo = infrastructure.NewOpenAIAdapter(cfg.LLM.APIKey, cfg.LLM.BaseURL)
    case "doubao":
        repo = infrastructure.NewDoubaoAdapter(cfg.LLM.APIKey, cfg.LLM.BaseURL)
    case "ollama":
        repo = infrastructure.NewOllamaAdapter(cfg.LLM.BaseURL)
    default:
        return nil, fmt.Errorf("unsupported LLM provider: %s", cfg.LLM.Type)
    }
    
    // 验证连接
    if err := repo.ValidateConnection(context.Background(), aggregate.Config{
        Provider: cfg.LLM.Type,
        Model:    cfg.LLM.Model,
        APIKey:   cfg.LLM.APIKey,
        BaseURL:  cfg.LLM.BaseURL,
    }); err != nil {
        logger.WarnTag("引导", "LLM连接验证失败: %v", err)
    }
    
    return domainllm.NewService(repo), nil
}
```

#### 2.2 TTS 和 ASR 领域重构

**2.2.1 TTS 领域实现**

创建文件：`internal/domain/tts/service.go`

```go
package tts

import (
    "context"
    "io"
    "xiaozhi-server-go/internal/domain/tts/aggregate"
)

type Service interface {
    Synthesize(ctx context.Context, req SynthesizeRequest) (*SynthesizeResponse, error)
    GetVoices(ctx context.Context, provider string) ([]Voice, error)
    ValidateConfig(config aggregate.Config) error
}

type SynthesizeRequest struct {
    Text     string
    Voice    string
    Provider string
    Config   aggregate.Config
}

type SynthesizeResponse struct {
    AudioData io.Reader
    Format    string
    Duration  float64
    Size      int64
}

type Voice struct {
    Name        string
    DisplayName string
    Language    string
    Gender      string
    Description string
}
```

创建文件：`internal/domain/tts/aggregate/config.go`

```go
package aggregate

type Config struct {
    Provider      string  `json:"provider"`
    Voice         string  `json:"voice"`
    OutputDir     string  `json:"output_dir"`
    Format        string  `json:"format"`
    SampleRate    int     `json:"sample_rate"`
    Speed         float32 `json:"speed"`
    Pitch         float32 `json:"pitch"`
    Volume        float32 `json:"volume"`
    APIKey        string  `json:"api_key"`
    AppID         string  `json:"app_id"`
    Token         string  `json:"token"`
    Cluster       string  `json:"cluster"`
}
```

**2.2.2 ASR 领域实现**

创建文件：`internal/domain/asr/service.go`

```go
package asr

import (
    "context"
    "io"
    "xiaozhi-server-go/internal/domain/asr/aggregate"
)

type Service interface {
    Transcribe(ctx context.Context, req TranscribeRequest) (*TranscribeResponse, error)
    StreamTranscribe(ctx context.Context, audioStream <-chan []byte) (<-chan TranscribeChunk, error)
    ValidateConfig(config aggregate.Config) error
}

type TranscribeRequest struct {
    AudioData io.Reader
    Format    string
    Language  string
    Provider  string
    Config    aggregate.Config
}

type TranscribeResponse struct {
    Text       string
    Language   string
    Duration   float64
    Confidence float64
}

type TranscribeChunk struct {
    Text      string
    IsFinal   bool
    Timestamp int64
    Confidence float64
}
```

#### 2.3 更新连接管理器

**2.3.1 重构 ConnectionHandler**

修改文件：connection.go

在结构体中添加新领域服务：

```go
type ConnectionHandler struct {
    // ... 现有字段 ...
    
    // 新架构领域服务
    llmService domainllm.Service
    ttsService domaintts.Service
    asrService domainasr.Service
}
```

在 `NewConnectionHandler` 函数中初始化：

```go
func NewConnectionHandler(
    config *configs.Config,
    providerSet *pool.ProviderSet,
    logger *utils.Logger,
    req *http.Request,
    ctx context.Context,
) *ConnectionHandler {
    handler := &ConnectionHandler{
        config: config,
        logger: logger,
        // ... 其他初始化 ...
    }
    
    // 初始化新架构服务（暂时保持旧的provider作为后备）
    if providerSet != nil {
        handler.providers.asr = providerSet.ASR
        handler.providers.llm = providerSet.LLM
        handler.providers.tts = providerSet.TTS
        
        // 新架构服务初始化（后续阶段完善）
        // handler.llmService = providerSet.LLMService
        // handler.ttsService = providerSet.TTSService
        // handler.asrService = providerSet.ASRService
    }
    
    // ... 其余初始化 ...
}
```

### 验收标准
- [x] LLM 领域完全独立，不依赖 src/
- [x] TTS 和 ASR 领域接口定义完成
- [x] 核心对话功能在新架构上正常工作
- [x] 性能测试通过（响应时间 < 2秒）
- [x] 单元测试覆盖率 >85%
- [x] 运行 `go test domain.` 通过

## 阶段3：外围模块迁移（第9-14周）

### 目标
迁移剩余模块，完善新架构。

#### 3.1 传输层重构

**3.1.1 HTTP 传输层**

创建文件：server.go

```go
package http

import (
    "context"
    "net/http"
    "time"
    
    "github.com/gin-gonic/gin"
    "xiaozhi-server-go/internal/domain/auth"
    "xiaozhi-server-go/internal/domain/ota"
    "xiaozhi-server-go/internal/domain/vision"
    "xiaozhi-server-go/internal/platform/config"
    "xiaozhi-server-go/internal/platform/errors"
    "xiaozhi-server-go/internal/platform/logging"
)

type Server struct {
    config       *config.Config
    logger       *logging.Logger
    router       *gin.Engine
    httpServer   *http.Server
    authService  auth.Service
    otaService   ota.Service
    visionService vision.Service
}

func NewServer(
    cfg *config.Config,
    logger *logging.Logger,
    authSvc auth.Service,
    otaSvc ota.Service,
    visionSvc vision.Service,
) *Server {
    r := gin.New()
    
    s := &Server{
        config:        cfg,
        logger:        logger,
        router:        r,
        authService:   authSvc,
        otaService:    otaSvc,
        visionService: visionSvc,
    }
    
    s.setupMiddleware()
    s.setupRoutes()
    
    s.httpServer = &http.Server{
        Addr:    fmt.Sprintf(":%d", cfg.Web.Port),
        Handler: r,
    }
    
    return s
}

func (s *Server) setupMiddleware() {
    s.router.Use(gin.Logger())
    s.router.Use(gin.Recovery())
    s.router.Use(s.corsMiddleware())
    s.router.Use(s.authMiddleware())
}

func (s *Server) setupRoutes() {
    // API 路由组
    api := s.router.Group("/api")
    api.GET("/health", s.handleHealth)
    
    // OTA 路由
    otaGroup := api.Group("/ota")
    otaGroup.POST("/upgrade", s.handleOTAUpgrade)
    otaGroup.GET("/status", s.handleOTAStatus)
    
    // Vision 路由
    visionGroup := api.Group("/vision")
    visionGroup.POST("/analyze", s.handleVisionAnalyze)
    
    // WebSocket 路由
    s.router.GET("/ws", s.handleWebSocket)
    
    // 静态文件服务
    s.router.Static("/static", "./web/static")
    
    // SPA 路由
    s.router.NoRoute(s.handleSPA)
}

func (s *Server) Start(ctx context.Context) error {
    s.logger.Info("Starting HTTP server on port %d", s.config.Web.Port)
    
    go func() {
        <-ctx.Done()
        shutdownCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()
        
        if err := s.httpServer.Shutdown(shutdownCtx); err != nil {
            s.logger.Error("HTTP server shutdown error: %v", err)
        }
    }()
    
    if err := s.httpServer.ListenAndServe(); err != nil && err != http.ErrServerClosed {
        return errors.Wrap(errors.KindTransport, "http.start", "server start failed", err)
    }
    
    return nil
}

func (s *Server) corsMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        c.Header("Access-Control-Allow-Origin", "*")
        c.Header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
        c.Header("Access-Control-Allow-Headers", "Content-Type, Authorization")
        
        if c.Request.Method == "OPTIONS" {
            c.AbortWithStatus(204)
            return
        }
        
        c.Next()
    }
}

func (s *Server) authMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // 实现认证中间件
        if s.authService != nil {
            // 验证token等
        }
        c.Next()
    }
}

// 处理函数实现
func (s *Server) handleHealth(c *gin.Context) {
    c.JSON(200, gin.H{
        "status": "ok",
        "timestamp": time.Now().Unix(),
    })
}

func (s *Server) handleOTAUpgrade(c *gin.Context) {
    // OTA 升级处理
    if s.otaService == nil {
        c.JSON(500, gin.H{"error": "OTA service not available"})
        return
    }
    
    // 实现OTA升级逻辑
    c.JSON(200, gin.H{"status": "upgrade initiated"})
}

func (s *Server) handleOTAStatus(c *gin.Context) {
    // OTA 状态查询
    c.JSON(200, gin.H{"status": "idle"})
}

func (s *Server) handleVisionAnalyze(c *gin.Context) {
    // 视觉分析处理
    if s.visionService == nil {
        c.JSON(500, gin.H{"error": "Vision service not available"})
        return
    }
    
    // 实现视觉分析逻辑
    c.JSON(200, gin.H{"result": "analysis completed"})
}

func (s *Server) handleWebSocket(c *gin.Context) {
    // WebSocket 处理
    // 升级到WebSocket连接
}

func (s *Server) handleSPA(c *gin.Context) {
    // SPA 路由处理
    c.File("./web/index.html")
}
```

#### 3.2 存储层重构

**3.2.1 统一存储接口**

创建文件：`internal/platform/storage/interface.go`

```go
package storage

import (
    "context"
    "io"
    "time"
)

type Storage interface {
    Upload(ctx context.Context, key string, reader io.Reader, metadata map[string]string) error
    Download(ctx context.Context, key string) (io.ReadCloser, error)
    Delete(ctx context.Context, key string) error
    List(ctx context.Context, prefix string) ([]ObjectInfo, error)
    GetMetadata(ctx context.Context, key string) (map[string]string, error)
    Exists(ctx context.Context, key string) (bool, error)
}

type ObjectInfo struct {
    Key          string
    Size         int64
    LastModified time.Time
    ETag         string
    Metadata     map[string]string
}

type Database interface {
    Get(ctx context.Context, key string) (string, error)
    Set(ctx context.Context, key string, value string, ttl time.Duration) error
    Delete(ctx context.Context, key string) error
    Exists(ctx context.Context, key string) (bool, error)
    Expire(ctx context.Context, key string, ttl time.Duration) error
    TTL(ctx context.Context, key string) (time.Duration, error)
}

type Cache interface {
    Get(ctx context.Context, key string) (string, error)
    Set(ctx context.Context, key string, value string, ttl time.Duration) error
    Delete(ctx context.Context, key string) error
    Exists(ctx context.Context, key string) (bool, error)
}
```

**3.2.2 实现文件存储**

创建文件：`internal/platform/storage/filesystem.go`

```go
package storage

import (
    "context"
    "io"
    "os"
    "path/filepath"
    "strings"
    "time"
    
    "xiaozhi-server-go/internal/platform/errors"
)

type FileSystemStorage struct {
    basePath string
}

func NewFileSystemStorage(basePath string) Storage {
    return &FileSystemStorage{basePath: basePath}
}

func (fs *FileSystemStorage) Upload(ctx context.Context, key string, reader io.Reader, metadata map[string]string) error {
    fullPath := filepath.Join(fs.basePath, key)
    
    // 确保目录存在
    dir := filepath.Dir(fullPath)
    if err := os.MkdirAll(dir, 0755); err != nil {
        return errors.Wrap(errors.KindPlatform, "filesystem.upload", "create directory failed", err)
    }
    
    file, err := os.Create(fullPath)
    if err != nil {
        return errors.Wrap(errors.KindPlatform, "filesystem.upload", "create file failed", err)
    }
    defer file.Close()
    
    _, err = io.Copy(file, reader)
    if err != nil {
        return errors.Wrap(errors.KindPlatform, "filesystem.upload", "copy data failed", err)
    }
    
    return nil
}

func (fs *FileSystemStorage) Download(ctx context.Context, key string) (io.ReadCloser, error) {
    fullPath := filepath.Join(fs.basePath, key)
    
    file, err := os.Open(fullPath)
    if err != nil {
        if os.IsNotExist(err) {
            return nil, errors.Wrap(errors.KindPlatform, "filesystem.download", "file not found", err)
        }
        return nil, errors.Wrap(errors.KindPlatform, "filesystem.download", "open file failed", err)
    }
    
    return file, nil
}

func (fs *FileSystemStorage) Delete(ctx context.Context, key string) error {
    fullPath := filepath.Join(fs.basePath, key)
    
    err := os.Remove(fullPath)
    if err != nil && !os.IsNotExist(err) {
        return errors.Wrap(errors.KindPlatform, "filesystem.delete", "remove file failed", err)
    }
    
    return nil
}

func (fs *FileSystemStorage) List(ctx context.Context, prefix string) ([]ObjectInfo, error) {
    searchPath := filepath.Join(fs.basePath, prefix)
    
    var objects []ObjectInfo
    
    err := filepath.Walk(searchPath, func(path string, info os.FileInfo, err error) error {
        if err != nil {
            return err
        }
        
        if info.IsDir() {
            return nil
        }
        
        relPath, err := filepath.Rel(fs.basePath, path)
        if err != nil {
            return err
        }
        
        objects = append(objects, ObjectInfo{
            Key:          relPath,
            Size:         info.Size(),
            LastModified: info.ModTime(),
        })
        
        return nil
    })
    
    if err != nil {
        return nil, errors.Wrap(errors.KindPlatform, "filesystem.list", "walk directory failed", err)
    }
    
    return objects, nil
}

func (fs *FileSystemStorage) GetMetadata(ctx context.Context, key string) (map[string]string, error) {
    fullPath := filepath.Join(fs.basePath, key)
    
    info, err := os.Stat(fullPath)
    if err != nil {
        if os.IsNotExist(err) {
            return nil, errors.Wrap(errors.KindPlatform, "filesystem.metadata", "file not found", err)
        }
        return nil, errors.Wrap(errors.KindPlatform, "filesystem.metadata", "stat file failed", err)
    }
    
    metadata := map[string]string{
        "size":         fmt.Sprintf("%d", info.Size()),
        "modified":     info.ModTime().Format(time.RFC3339),
        "permissions":  info.Mode().String(),
    }
    
    return metadata, nil
}

func (fs *FileSystemStorage) Exists(ctx context.Context, key string) (bool, error) {
    fullPath := filepath.Join(fs.basePath, key)
    
    _, err := os.Stat(fullPath)
    if err == nil {
        return true, nil
    }
    
    if os.IsNotExist(err) {
        return false, nil
    }
    
    return false, errors.Wrap(errors.KindPlatform, "filesystem.exists", "stat file failed", err)
}
```

#### 3.3 任务管理迁移

**3.3.1 领域任务服务**

创建文件：`internal/domain/task/service.go`

```go
package task

import (
    "context"
    "time"
    "xiaozhi-server-go/internal/domain/task/aggregate"
)

type Service interface {
    SubmitTask(ctx context.Context, req SubmitTaskRequest) (*Task, error)
    GetTaskStatus(ctx context.Context, taskID string) (*TaskStatus, error)
    CancelTask(ctx context.Context, taskID string) error
    ListTasks(ctx context.Context, filter TaskFilter) ([]Task, error)
}

type SubmitTaskRequest struct {
    Type       string
    Payload    interface{}
    Priority   Priority
    Timeout    time.Duration
    Callback   func(result interface{}, err error)
    Metadata   map[string]string
}

type Task struct {
    ID          string
    Type        string
    Status      Status
    Priority    Priority
    Payload     interface{}
    Result      interface{}
    Error       string
    CreatedAt   time.Time
    UpdatedAt   time.Time
    StartedAt   *time.Time
    CompletedAt *time.Time
    Timeout     time.Duration
    Metadata    map[string]string
}

type TaskStatus struct {
    ID       string
    Status   Status
    Progress float64
    Message  string
}

type TaskFilter struct {
    Status   Status
    Type     string
    Limit    int
    Offset   int
}

type Status int

const (
    StatusPending Status = iota
    StatusRunning
    StatusCompleted
    StatusFailed
    StatusCancelled
)

type Priority int

const (
    PriorityLow Priority = iota
    PriorityNormal
    PriorityHigh
    PriorityUrgent
)
```

### 验收标准
- [ ] HTTP 传输层完全迁移
- [ ] 存储层统一接口实现
- [ ] 任务管理在新架构中工作
- [ ] 所有 API 接口保持兼容
- [ ] 集成测试覆盖所有场景

## 阶段4：清理和优化（第15-16周）

### 目标
移除旧架构代码，优化新架构。

#### 4.1 移除旧代码

**4.1.1 逐步删除 src/ 目录**

执行命令：
```bash
# 备份当前代码
git tag archive/src-before-removal
git branch archive/src-backup

# 逐步删除已迁移的模块
rm -rf src/core/providers/  # LLM/TTS/ASR 已迁移
rm -rf src/httpsvr/         # HTTP 服务已迁移
rm -rf src/configs/         # 配置管理已迁移
rm -rf src/task/            # 任务管理已迁移

# 更新导入语句
find . -name "*.go" -not -path "./vendor/*" -exec sed -i 's|xiaozhi-server-go/src/|xiaozhi-server-go/internal/|g' {} \;

# 验证没有遗留引用
grep -r "xiaozhi-server-go/src/" internal/ || echo "✅ No src/ references found"
```

**4.1.2 更新项目结构**

重命名目录（可选）：
```bash
# 如果需要重命名 internal 为 src
mv internal src_new
rm -rf src  # 删除旧的 src
mv src_new src
```

更新 go.mod：
```go
# 如果重命名了目录，需要更新模块路径
find . -name "*.go" -exec sed -i 's|xiaozhi-server-go/internal/|xiaozhi-server-go/src/|g' {} \;
```

#### 4.2 性能优化

**4.2.1 连接池优化**

创建文件：manager.go

```go
package pool

import (
    "context"
    "sync"
    "sync/atomic"
    "time"
    
    "xiaozhi-server-go/internal/platform/errors"
)

type PoolManager struct {
    pools   map[string]*ResourcePool
    mu      sync.RWMutex
    closed  atomic.Bool
}

type ResourcePool struct {
    name      string
    factory   func() (interface{}, error)
    destroyer func(interface{})
    resources chan interface{}
    maxSize   int
    created   int64
    inUse     int64
}

func NewPoolManager() *PoolManager {
    return &PoolManager{
        pools: make(map[string]*ResourcePool),
    }
}

func (pm *PoolManager) CreatePool(name string, maxSize int, factory func() (interface{}, error), destroyer func(interface{})) {
    pm.mu.Lock()
    defer pm.mu.Unlock()
    
    pool := &ResourcePool{
        name:      name,
        factory:   factory,
        destroyer: destroyer,
        resources: make(chan interface{}, maxSize),
        maxSize:   maxSize,
    }
    
    pm.pools[name] = pool
}

func (pm *PoolManager) Get(name string) (interface{}, error) {
    pm.mu.RLock()
    pool, exists := pm.pools[name]
    pm.mu.RUnlock()
    
    if !exists {
        return nil, errors.New(errors.KindPlatform, "pool.get", "pool not found: "+name)
    }
    
    // 尝试从池中获取
    select {
    case resource := <-pool.resources:
        atomic.AddInt64(&pool.inUse, 1)
        return resource, nil
    default:
        // 池为空，创建新资源
        resource, err := pool.factory()
        if err != nil {
            return nil, errors.Wrap(errors.KindPlatform, "pool.get", "factory failed", err)
        }
        
        atomic.AddInt64(&pool.created, 1)
        atomic.AddInt64(&pool.inUse, 1)
        return resource, nil
    }
}

func (pm *PoolManager) Put(name string, resource interface{}) error {
    pm.mu.RLock()
    pool, exists := pm.pools[name]
    pm.mu.RUnlock()
    
    if !exists {
        return errors.New(errors.KindPlatform, "pool.put", "pool not found: "+name)
    }
    
    select {
    case pool.resources <- resource:
        atomic.AddInt64(&pool.inUse, -1)
        return nil
    default:
        // 池已满，销毁资源
        if pool.destroyer != nil {
            pool.destroyer(resource)
        }
        atomic.AddInt64(&pool.inUse, -1)
        return nil
    }
}

func (pm *PoolManager) Stats(name string) map[string]int64 {
    pm.mu.RLock()
    pool, exists := pm.pools[name]
    pm.mu.RUnlock()
    
    if !exists {
        return nil
    }
    
    return map[string]int64{
        "created": atomic.LoadInt64(&pool.created),
        "in_use":  atomic.LoadInt64(&pool.inUse),
        "available": int64(len(pool.resources)),
        "max_size": int64(pool.maxSize),
    }
}

func (pm *PoolManager) Close() {
    if !pm.closed.CompareAndSwap(false, true) {
        return
    }
    
    pm.mu.Lock()
    defer pm.mu.Unlock()
    
    for name, pool := range pm.pools {
        close(pool.resources)
        
        // 清空池中剩余资源
        for {
            select {
            case resource := <-pool.resources:
                if pool.destroyer != nil {
                    pool.destroyer(resource)
                }
            default:
                goto nextPool
            }
        }
        
        nextPool:
        delete(pm.pools, name)
    }
}
```

**4.2.2 缓存优化**

创建文件：`internal/platform/cache/redis.go`

```go
package cache

import (
    "context"
    "encoding/json"
    "time"
    
    "github.com/redis/go-redis/v9"
    "xiaozhi-server-go/internal/platform/errors"
)

type RedisCache struct {
    client *redis.Client
}

func NewRedisCache(addr, password string, db int) Cache {
    client := redis.NewClient(&redis.Options{
        Addr:     addr,
        Password: password,
        DB:       db,
    })
    
    return &RedisCache{client: client}
}

func (rc *RedisCache) Get(ctx context.Context, key string) (string, error) {
    val, err := rc.client.Get(ctx, key).Result()
    if err == redis.Nil {
        return "", errors.New(errors.KindPlatform, "cache.get", "key not found")
    }
    if err != nil {
        return "", errors.Wrap(errors.KindPlatform, "cache.get", "redis get failed", err)
    }
    return val, nil
}

func (rc *RedisCache) Set(ctx context.Context, key string, value string, ttl time.Duration) error {
    err := rc.client.Set(ctx, key, value, ttl).Err()
    if err != nil {
        return errors.Wrap(errors.KindPlatform, "cache.set", "redis set failed", err)
    }
    return nil
}

func (rc *RedisCache) Delete(ctx context.Context, key string) error {
    err := rc.client.Del(ctx, key).Err()
    if err != nil {
        return errors.Wrap(errors.KindPlatform, "cache.delete", "redis del failed", err)
    }
    return nil
}

func (rc *RedisCache) Exists(ctx context.Context, key string) (bool, error) {
    count, err := rc.client.Exists(ctx, key).Result()
    if err != nil {
        return false, errors.Wrap(errors.KindPlatform, "cache.exists", "redis exists failed", err)
    }
    return count > 0, nil
}

func (rc *RedisCache) GetJSON(ctx context.Context, key string, dest interface{}) error {
    val, err := rc.Get(ctx, key)
    if err != nil {
        return err
    }
    
    err = json.Unmarshal([]byte(val), dest)
    if err != nil {
        return errors.Wrap(errors.KindPlatform, "cache.getjson", "json unmarshal failed", err)
    }
    
    return nil
}

func (rc *RedisCache) SetJSON(ctx context.Context, key string, value interface{}, ttl time.Duration) error {
    data, err := json.Marshal(value)
    if err != nil {
        return errors.Wrap(errors.KindPlatform, "cache.setjson", "json marshal failed", err)
    }
    
    return rc.Set(ctx, key, string(data), ttl)
}
```

#### 4.3 最终验证

**4.3.1 完整性检查**

执行命令：
```bash
# 检查代码完整性
go mod tidy
go build ./cmd/xiaozhi-server

# 运行完整测试套件
go test ./... -v -race -coverprofile=coverage.out

# 生成覆盖率报告
go tool cover -html=coverage.out -o coverage.html

# 性能基准测试
go test -bench=. -benchmem ./... > bench.out

# 静态分析
golangci-lint run

# 检查是否有遗留的旧代码引用
grep -r "src/core/providers" . --exclude-dir=.git --exclude-dir=vendor || echo "✅ No legacy provider references"
grep -r "src/configs" . --exclude-dir=.git --exclude-dir=vendor || echo "✅ No legacy config references"
```

**4.3.2 性能基准测试**

创建文件：`internal/domain/llm/service_bench_test.go`

```go
package llm

import (
    "context"
    "testing"
    "xiaozhi-server-go/internal/domain/llm/aggregate"
    "xiaozhi-server-go/internal/platform/testing"
)

func BenchmarkService_GenerateResponse(b *testing.B) {
    // 设置测试环境
    cfg := testing.SetupTestConfig(b)
    logger := testing.SetupTestLogger(b)
    
    // 创建模拟仓库
    repo := &mockRepository{}
    
    // 创建服务
    svc := NewService(repo)
    
    // 准备测试请求
    req := GenerateRequest{
        SessionID: "test-session",
        Messages: []aggregate.Message{
            {
                Role:    "user",
                Content: "Hello, how are you?",
            },
        },
        Config: aggregate.Config{
            Provider: "test",
            Model:    "test-model",
        },
    }
    
    b.ResetTimer()
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            _, err := svc.GenerateResponse(context.Background(), req)
            if err != nil {
                b.Fatal(err)
            }
        }
    })
}

func BenchmarkService_StreamResponse(b *testing.B) {
    // 类似上面的实现，但测试流式响应
    cfg := testing.SetupTestConfig(b)
    logger := testing.SetupTestLogger(b)
    
    repo := &mockRepository{}
    svc := NewService(repo)
    
    req := GenerateRequest{
        SessionID: "test-session",
        Messages: []aggregate.Message{
            {
                Role:    "user",
                Content: "Tell me a story",
            },
        },
        Config: aggregate.Config{
            Provider: "test",
            Model:    "test-model",
        },
    }
    
    b.ResetTimer()
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            stream, err := svc.StreamResponse(context.Background(), req)
            if err != nil {
                b.Fatal(err)
            }
            
            // 消费流
            for range stream {
                // 消费数据
            }
        }
    })
}

// mockRepository 模拟仓库实现
type mockRepository struct{}

func (m *mockRepository) Generate(ctx context.Context, req repository.GenerateRequest) (*repository.GenerateResult, error) {
    return &repository.GenerateResult{
        Content:      "This is a mock response",
        FinishReason: "stop",
        Usage: &aggregate.Usage{
            PromptTokens:     10,
            CompletionTokens: 20,
            TotalTokens:      30,
        },
    }, nil
}

func (m *mockRepository) Stream(ctx context.Context, req repository.GenerateRequest) (<-chan repository.ResponseChunk, error) {
    outChan := make(chan repository.ResponseChunk, 10)
    
    go func() {
        defer close(outChan)
        
        chunks := []string{"This", " is", " a", " mock", " streaming", " response"}
        for i, chunk := range chunks {
            outChan <- repository.ResponseChunk{
                Content: chunk,
                Done:    i == len(chunks)-1,
            }
        }
    }()
    
    return outChan, nil
}

func (m *mockRepository) ValidateConnection(ctx context.Context, config aggregate.Config) error {
    return nil
}

func (m *mockRepository) GetProviderInfo(provider string) (*repository.ProviderInfo, error) {
    return &repository.ProviderInfo{
        Name:         "Mock Provider",
        SupportedModels: []string{"mock-model"},
        MaxTokens:    4096,
        Features:     []string{"chat", "streaming"},
    }, nil
}
```

### 验收标准
- [ ] src/ 目录完全移除
- [ ] 所有导入语句更新完成
- [ ] 项目完全在新架构上运行
- [ ] 性能提升 10%以上
- [ ] 代码行数减少 25%
- [ ] 单元测试覆盖率 >85%
- [ ] 所有集成测试通过

## 监控和质量保证

### 质量指标
- **代码质量：** SonarQube 评分 > A
- **测试覆盖：** >85%
- **性能基准：** 响应时间 < 2秒，内存使用 < 500MB
- **错误率：** < 0.1%

### 监控工具
```yaml
# docker-compose.monitoring.yml
version: '3.8'
services:
  prometheus:
    image: prom/prometheus:latest
    ports:
      - "9090:9090"
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
    
  grafana:
    image: grafana/grafana:latest
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin
    volumes:
      - grafana_data:/var/lib/grafana
    
  jaeger:
    image: jaegertracing/all-in-one:latest
    ports:
      - "16686:16686"
      - "14268:14268"
    environment:
      - COLLECTOR_OTLP_ENABLED=true
    
  loki:
    image: grafana/loki:latest
    ports:
      - "3100:3100"
    volumes:
      - loki_data:/loki
    
  promtail:
    image: grafana/promtail:latest
    volumes:
      - ./logs:/var/log/xiaozhi
      - ./monitoring/promtail.yml:/etc/promtail/promtail.yml
    command:
      - '--config.file=/etc/promtail/promtail.yml'

volumes:
  grafana_data:
  loki_data:
```

### 回滚计划
- **每日备份：** 自动备份代码和数据库
- **检查点：** 每个阶段结束创建 Git 标签
- **快速回滚：** 脚本化回滚流程

```bash
#!/bin/bash
# rollback.sh
echo "Starting rollback process..."

# 停止服务
docker-compose down

# 回滚代码
git reset --hard HEAD~1
git push --force-with-lease

# 恢复数据库备份
# ... 数据库恢复逻辑 ...

# 重启服务
docker-compose up -d

echo "Rollback completed"
```

## 风险管理

### 技术风险
| 风险 | 概率 | 影响 | 缓解措施 |
|------|------|------|----------|
| 迁移导致功能缺失 | 中 | 高 | 分阶段迁移，充分测试 |
| 性能下降 | 中 | 中 | 性能基准测试，优化池化 |
| 依赖冲突 | 低 | 高 | 统一依赖管理，使用Go modules |

### 业务风险
| 风险 | 概率 | 影响 | 缓解措施 |
|------|------|------|----------|
| 项目延期 | 中 | 中 | 设立里程碑，定期评审 |
| 团队疲劳 | 高 | 中 | 合理分配任务，适当休息 |

### 技术债务
| 债务 | 清理计划 | 优先级 |
|------|----------|--------|
| 循环依赖 | 阶段2完成 | 高 |
| 接口重复 | 阶段3完成 | 中 |
| 配置混乱 | 阶段2完成 | 高 |

## 团队组织

### 角色分工
- **架构师（1人）：** 总体设计，技术决策，代码评审
- **核心开发者（3人）：** 领域迁移，代码实现
  - 开发者A：LLM 领域迁移
  - 开发者B：TTS/ASR 领域迁移  
  - 开发者C：传输层和存储层迁移
- **测试工程师（2人）：** 测试用例编写，质量保证
- **DevOps（1人）：** CI/CD，部署，监控

### 沟通机制
- **每日站会：** 15分钟，同步进度和问题
- **周评审：** 1小时，阶段总结和计划调整
- **月汇报：** 向管理层汇报整体进度

### 培训计划
- **DDD 培训：** 第一周，4小时
- **新架构介绍：** 第一周，2小时  
- **代码规范培训：** 第二周，2小时

## 工具和资源

### 开发工具
- **IDE：** GoLand 或 VS Code with Go extension
- **版本控制：** Git with Git Flow
- **代码质量：** golangci-lint, SonarQube
- **测试：** Go testing framework, Testify, Mockery
- **文档：** MkDocs, Swagger/OpenAPI
- **容器化：** Docker, docker-compose

### 环境要求
- **Go 版本：** 1.21+
- **内存：** 8GB+
- **磁盘：** 50GB+
- **网络：** 稳定的互联网连接

### 第三方服务
- **CI/CD：** GitHub Actions
- **监控：** Prometheus + Grafana
- **日志：** Loki + Promtail
- **追踪：** Jaeger
- **存储：** MinIO (可选)

## 总结

本迁移计划采用渐进式策略，通过4个阶段逐步完成架构重构。重点关注：

1. **保持稳定性：** 每个阶段都保持系统可运行
2. **质量保证：** 完善的测试和监控体系
3. **风险控制：** 详细的回滚和应急计划
4. **团队协作：** 明确的角色分工和沟通机制

迁移完成后，项目将具备：
- 清晰的架构边界
- 高度的可测试性
- 优秀的可维护性
- 强大的扩展能力

**预计收益：**
- 开发效率提升 30%
- 缺陷率降低 50%
- 新功能上线时间缩短 40%
- 系统稳定性提升 25%

**关键成功因素：**
- 严格遵循分阶段计划
- 完善的测试覆盖
- 有效的沟通机制
- 持续的质量监控

---

*本文档版本：v1.0*  
*最后更新：2025年10月29日*  
*负责人：架构迁移小组*  
*审批人：技术总监*  

**附录：**
- 详细代码示例
- 测试策略
- 部署指南
- 故障排查